# часова складність алгоритму квадратична - O(n^2), бо вкладені цикли
# дуже повільний алгоритм для великих списків
# підходить для невеликих списків, частково відсортованих списків

def bubble_sort(lst_):
    lst = lst_.copy()
    n = len(lst)
    for i in range(n-1): # перебираємо всі елементи списку, зменшуючи кількість елементів на 1 після кожної ітерації, бо останній елемент вже відсортований
        for j in range(0, n-i-1): # порівнює два сусідні елементи і міняє їх місцями, якщо перший більший за другий
            if lst[j] > lst[j+1]: # порівнюємо два сусідні елементи
                lst[j], lst[j+1] = lst[j+1], lst[j] # кортеж, де міняються місцями елементи, якшо перший більший за другий
    return lst

if __name__ == '__main__':
    numbers = [5, 3, 8, 4, 2]
    print(bubble_sort(numbers)) # виведе: [2, 3, 4, 5, 8]

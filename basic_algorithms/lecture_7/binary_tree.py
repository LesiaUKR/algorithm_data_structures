# Binary tree search (двійкове дерево пошуку - ДДП) - це структура, яка має наступні властивості:
# 1. Кожен вузол має ключ.
# 2. Ключі в лівому піддереві будь-якого вузла завжди менші за його ключ.
# 3. Ключі в правому піддереві будь-якого вузла завжди більші за його ключ.
# 4. Ліве та праве піддерева також є ДДП.

# вставка, видалення та пошук даних у відсортованому ДДП дорівнюють О(log n)
# у середньому та О(n) у найгіршому випадку

# Для двійкового дерева пошуку час виконання основних операцій, таких як пошук, вставка та видалення, 
# залежить від форми дерева:

# 1. Оптимальний випадок (збалансоване дерево):
# - Вставка: O(logn)
# - Пошук: O(logn)
# - Видалення: O(logn)

# 2. Найгірший випадок (незбалансоване дерево):
# - Вставка: O(n)
# - Пошук: O(n)
# - Видалення: O(n)

# n — кількість вузлів у дереві

class Node:
    def __init__(self, key):
        # Ініціалізація вузла дерева
        self.left = None  # Ліва дитина
        self.right = None  # Права дитина
        self.val = key  # Значення вузла

    def __str__(self, level=0, prefix="Root: "):
        # Метод для гарного відображення дерева
        ret = "\t" * level + prefix + str(self.val) + "\n"
        if self.left:
            # Додаємо відображення лівого піддерева з відповідним префіксом
            ret += self.left.__str__(level + 1, "L--- ")
        if self.right:
            # Додаємо відображення правого піддерева з відповідним префіксом
            ret += self.right.__str__(level + 1, "R--- ")
        return ret

def insert(root, key):
    # Вставка нового ключа у дерево
    if root is None:
        # Якщо корінь дерева порожній, створюємо новий вузол
        return Node(key)
    else:
        if key < root.val:
            # Якщо ключ менший за значення кореня, вставляємо у ліве піддерево
            root.left = insert(root.left, key)
        else:
            # Якщо ключ більший або дорівнює значенню кореня, вставляємо у праве піддерево
            root.right = insert(root.right, key)
    # Повертаємо корінь дерева після вставки
    return root

def search(root, key):
    # Пошук вузла з заданим ключем у дереві
    if root is None or root.val == key:
        # Якщо вузол не знайдено або знайдено вузол з шуканим ключем, повертаємо його
        return root
    if key < root.val:
        # Якщо ключ менший за значення вузла, шукаємо у лівому піддереві
        return search(root.left, key)
    # Якщо ключ більший за значення вузла, шукаємо у правому піддереві
    return search(root.right, key)

def min_value_node(node):
    # Пошук вузла з мінімальним значенням у дереві
    current = node
    while current.left:
        # Продовжуємо рухатися до лівого піддерева, поки не знайдемо мінімальний вузол
        current = current.left
    return current

def delete(root, key):
    # Видалення вузла з деревом
    if not root:
        # Якщо дерево порожнє, повертаємо корінь
        return root

    if key < root.val:
        # Якщо ключ менший за значення кореня, видаляємо з лівого піддерева
        root.left = delete(root.left, key)
    elif key > root.val:
        # Якщо ключ більший за значення кореня, видаляємо з правого піддерева
        root.right = delete(root.right, key)
    else:
        # Якщо знайдено вузол з ключем, видаляємо його
        if not root.left:
            # Вузол без лівої дитини
            temp = root.right
            root = None
            return temp
        elif not root.right:
            # Вузол без правої дитини
            temp = root.left
            root = None
            return temp
        # Вузол з двома дітьми: знаходимо наступника (мінімальний вузол у правому піддереві)
        root.val = min_value_node(root.right).val
        # Видаляємо наступника у правому піддереві
        root.right = delete(root.right, root.val)
    return root

# Тестування
root = Node(5)  # Створюємо корінь дерева зі значенням 5
root = insert(root, 3)  # Вставляємо значення 3
root = insert(root, 2)  # Вставляємо значення 2
root = insert(root, 4)  # Вставляємо значення 4
root = insert(root, 7)  # Вставляємо значення 7
root = insert(root, 6)  # Вставляємо значення 6
root = insert(root, 8)  # Вставляємо значення 8

root = delete(root, 7)  # Видаляємо вузол зі значенням 7
print(root)  # Друкуємо дерево

val =  4
result = search(root, val)
if result:
    print(f"У дереві знайдено значення {result.val}")
else:
    print(f"У дереві не знайдено значення {val}")

# Видалення вузла з ДДП:
# 1. Вузол без дітей - просто видаляємо вузол
# 2. Вузол з однією дитиною - не складний випадок: видаляємо вузол і з'єднуємо його батька з його дитиною.
# 3. Вузол із двома дітьми. Два варіанти для заміни вузла, який ми видаляємо:
# а) Це може бути найбільший вузол у лівому піддереві (іноді називається predecessor) 
# б) або найменший вузол у правому піддереві (successor). 
# Видаляємо вузол, який вибрали для заміни, та замінюємо ним вузол, який тільки що видалили.
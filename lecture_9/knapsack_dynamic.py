# 3. Динамічне програмування (Dynamic programming) - складність O(n*W) -  поліноміальний час виконання, 
# оптимальний вибір, але вимагає багато пам'яті

# Параметри:
# W - місткість рюкзака.
# wt - список ваг предметів.
# val - список вартостей предметів.
# n - кількість предметів.

# Цей алгоритм має поліноміальну часову складність O(nW),
# де n — кількість предметів, 
# W — місткість рюкзака, 
# і є набагато ефективнішим, ніж повний перебір або жадібний підхід, 
# особливо для великих вхідних даних

# Значення K[i][w]:
# Максимальна вартість, яку можна отримати, використовуючи перші i
# предметів при місткості рюкзака w.

from tabulate import tabulate

# Реалізація динамічного програмування для задачі про рюкзак
def knapSack(W, wt, val, n):
    # створюємо таблицю K для зберігання оптимальних значень підзадач
    K = [[0 for w in range(W + 1)] for i in range(n + 1)]

    # будуємо таблицю K знизу вгору
    for i in range(n + 1):
        for w in range(W + 1):
            # якщо немає предметів або місткість рюкзака дорівнює нулю
            if i == 0 or w == 0:
                K[i][w] = 0
            # якщо вага поточного предмета менша або дорівнює поточній місткості рюкзака
            elif wt[i - 1] <= w:
                # обираємо максимум між включенням предмета та не включенням
                K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])
            else:
                # якщо вага предмета перевищує поточну місткість рюкзака, предмет не включаємо
                K[i][w] = K[i - 1][w]
    # створюємо заголовки для таблиці
    headers = [""] + [str(w) for w in range(W + 1)]
    table = []
    
    # додаємо рядки таблиці з підписами
    for i in range(n + 1):
        if i == 0:
            row = ["0"] + [K[i][w] for w in range(W + 1)]
        else:
            row = [f"{i}({wt[i - 1]})"] + [K[i][w] for w in range(W + 1)]
        table.append(row)

    # формат таблиці для збереження у файл
    table_str = tabulate(table, headers, tablefmt="pipe")
    
    # збереження таблиці у файл
    with open("knapsack_table.md", "w") as file:
        file.write(table_str)

    # повертаємо максимальну вартість, яку можна отримати при повній місткості рюкзака
    return K[n][W]

# ваги предметів
weight = [10, 20, 30]
# вартість предметів
value = [60, 100, 120]
# місткість рюкзака
capacity = 50
# кількість предметів
n = len(value)
# виклик функції та вивід результату
print(knapSack(capacity, weight, value, n))  # Очікуваний результат: 220

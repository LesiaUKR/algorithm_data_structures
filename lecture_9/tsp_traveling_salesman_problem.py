# Задача комівояжера (TSP – Traveling Salesman Problem) — це класична задача оптимізації,
# яка полягає в знаходженні найкоротшого можливого маршруту, за яким можна відвідати кожне
# місто лише один раз і повернутися до початкового міста. Це NP-повна задача, що означає, 
# що час знаходження точного рішення зростає експоненційно зі збільшенням кількості міст.


# NP-повна задача (NP-complete problem) — це один із класів задач у теорії складності обчислень.
# Щоб зрозуміти, що це означає, розглянемо кілька основних понять:

# Клас P: Це клас задач, які можуть бути розв'язані за поліноміальний час. 
# Тобто, якщо існує алгоритм, який може вирішити задачу за час, пропорційний деякому степеню
# від розміру вхідних даних (наприклад, O(n^2), O(n^3)), то така задача належить до класу P.

# Клас NP: Це клас задач, для яких можна перевірити правильність рішення за поліноміальний час.
# Інакше кажучи, якщо хтось надасть вам рішення задачі, ви зможете перевірити його 
# правильність за поліноміальний час.

# NP-повна задача: Це особливий клас задач у NP, які задовольняють дві умови:

# 1. NP-тяжкість: Будь-яка задача з NP може бути зведена до цієї задачі за поліноміальний час. 
# Це означає, що розв'язавши одну NP-повну задачу, можна розв'язати будь-яку задачу з класу NP.
# 2. NP-належність: Задача сама належить до класу NP, тобто, її рішення може бути перевірене за поліноміальний час.

# для наших п'яти міст ми отримуємо 5!=120 можливих перестановок, 
# а для десяти міст — уже жахливих 10!=3_628_800 перестановок!

# Розв'язання методом грубої сили (Brute Force) або повного перебору - складність є факторіальною O(n!) 


from itertools import permutations # імпортуємо функцію для генерації всіх можливих перестановок міст
from math import sqrt # імпортуємо функцію для обчислення квадратного кореня

# Визначити координати для 5 міст
cities = {"A": (0, 0), "B": (1, 5), "C": (2, 2), "D": (3, 3), "E": (5, 1)}

# Визначити координати для 5 міст
cities = {"A": (0, 0), "B": (1, 5), "C": (2, 2), "D": (3, 3), "E": (5, 1)}

# Функція для обчислення відстані між двома містами
def distance(first_city_name, second_city_name):
    x1, y1 = cities[first_city_name]  # Отримуємо координати першого міста
    x2, y2 = cities[second_city_name] # Отримуємо координати другого міста
    return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)  # Обчислюємо відстань за формулою Евкліда

def total_distance_with_return(tour):
    # Загальна відстань, включаючи повернення до початкової точки
    return sum(distance(tour[i], tour[i + 1]) for i in range(len(tour) - 1)) + distance(
        tour[-1], tour[0]
    )

# Знайти найкоротший маршрут
all_tours = permutations(cities.keys())  # Генеруємо всі можливі маршрути (перестановки міст)
shortest_tour = min(all_tours, key=total_distance_with_return)  # Знаходимо маршрут з мінімальною відстанню
# Переобчислити відстань найкоротшого маршруту з урахуванням зворотного шляху
shortest_distance_with_return = total_distance_with_return(shortest_tour)  # Обчислюємо відстань для найкоротшого маршруту

print(shortest_tour, shortest_distance_with_return)  # Виводимо найкоротший маршрут та його довжину

# Пірамідальне сортування (Heap Sort) — це метод сортування, що використовує структуру даних піраміда (heap)
# для сортування елементів за зростанням чи спаданням.

# Пірамідальне сортування має часову складність O(n log n) для найгіршого, середнього та кращого випадку.
# Це робить його ефективним методом сортування для великих масивів даних.

# 1. Створення піраміди (heapify) — перетворення масиву елементів у піраміду.
# 2. Для кожного елемента масиву (починаючи з кінця і рухаючись до кореня) поміняємо місцями корінь з останнім елементом.
# 3. Виключаємо останній елемент (тепер він уже відсортований) з купи.

import heapq  # Імпортуємо модуль heapq для роботи з мінімальною купою (heap).

# Функція пірамідального сортування за зростанням.
def heap_sort(iterable):  # Визначаємо функцію heap_sort, яка приймає ітерабельний об'єкт (наприклад, список).
    h = []  # Створюємо порожній список, який буде використовуватись як купа.
    for value in iterable:  # Проходимося по кожному елементу в ітерабельному об'єкті.
        heapq.heappush(h, value)  # Додаємо кожен елемент до купи, зберігаючи властивість мінімальної купи.
    
    # Витягуємо елементи впорядковано, формуючи відсортований масив.
    return [heapq.heappop(h) for _ in range(len(h))]  # Створюємо новий список, в якому елементи витягуються з купи у впорядкованому вигляді.

# Масив для сортування
arr = [12, 11, 13, 5, 6, 7]  # Початковий масив, який потрібно відсортувати.
sorted_arr = heap_sort(arr)  # Викликаємо функцію heap_sort для сортування масиву.
print("Відсортований масив (за зростанням):", sorted_arr)  # Виводимо відсортований масив.
# Output: Відсортований масив: [5, 6, 7, 11, 12, 13]

# Пірамідальне сортування за спаданням
def heap_sort_desc(iterable):  # Визначаємо функцію heap_sort_desc, яка приймає ітерабельний об'єкт (наприклад, список).
    h = []  # Створюємо порожній список, який буде використовуватись як купа.
    # Вставляємо в купу від'ємні значення
    for value in iterable:  # Проходимося по кожному елементу в ітерабельному об'єкті.
        heapq.heappush(h, -value)  # Додаємо кожен елемент до купи у вигляді від'ємного значення, щоб створити максимальну купу.
    
    # Витягуємо елементи і міняємо знаки для відновлення оригінальних значень
    return [-heapq.heappop(h) for _ in range(len(h))]  # Створюємо новий список, в якому елементи витягуються з купи у впорядкованому вигляді (за спаданням) з поверненням знаків.

arr = [12, 11, 13, 5, 6, 7]  # Початковий масив, який потрібно відсортувати.
sorted_arr_desc = heap_sort_desc(arr)  # Викликаємо функцію heap_sort_desc для сортування масиву за спаданням.
print("Відсортований масив (за спаданням):", sorted_arr_desc)  # Виводимо відсортований масив за спаданням.


# Пірамідальне сортування з вибором напрямку сортування (за зростанням або за спаданням)
import heapq

def heap_sort(iterable, descending=False):
    # Визначаємо, який знак використовувати залежно від порядку сортування
    sign = -1 if descending else 1

    # Створюємо купу, використовуючи заданий порядок сортування
    h = [sign * el for el in iterable]
    heapq.heapify(h)
    
    # Витягуємо елементи, відновлюємо їхні оригінальні значення (якщо потрібно) і формуємо відсортований масив
    return [sign * heapq.heappop(h) for _ in range(len(h))]

# Приклади використання функції
arr = [12, 11, 13, 5, 6, 7]

# Сортування за зростанням (за замовчуванням)
sorted_arr_asc = heap_sort(arr)
print("Відсортований масив (за зростанням):", sorted_arr_asc)

# Сортування за спаданням
sorted_arr_desc = heap_sort(arr, descending=True)
print("Відсортований масив (за спаданням):", sorted_arr_desc)
